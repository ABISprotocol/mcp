#!/usr/bin/env node

var fs = require('fs');
var program = require('commander');
var EncFile = require('bitcore/util/EncFile');
var timeUtil = require('bitcore/util/time');
var coinUtil = require('bitcore/util/util');
var Transaction = require('bitcore/Transaction');
var Parser = require('bitcore/util/BinaryParser');
var jrpcServer = require('../jrpcServer');
var kvfile = require('../kvfile');
var winston = require('winston');
var RpcClient = require('bitcore/RpcClient');
var Script = require('bitcore/Script');
var Address = require('bitcore/Address');
var Wallet = require('bitcore/Wallet');

var VERSION = '0.0.1';
var ENC_METHOD = 'aes-256-cbc';

program
	.version(VERSION)
	.option('--init', 'Initialize database')
	.option('-c, --config <file>', 'key=value configuration file')
	.parse(process.argv);

var logger = new (winston.Logger)({
	transports: [
		new (winston.transports.Console)({ timestamp: true }),
	],
});
var cfg_fn = program.config || 'serverd.cfg';
var cfg = kvfile.readSync(cfg_fn);
if (cfg.log)
	logger.add(winston.transports.File, { 
		filename: cfg.log,
		timestamps: true,
	});

// load global configuration
var db_fn = cfg.db || 'serverd.db';
var sslkey_fn = cfg.ssl_key || 'server.key';
var sslcert_fn = cfg.ssl_cert || 'server.cert';
var walletdb_fn = cfg.wallet || 'server.wallet';
var timelock_min = parseInt(cfg.timelock_min) || 3600;
var timelock_max = parseInt(cfg.timelock_max) || (3600 * 24);
var timelock_prefer = parseInt(cfg.timelock_prefer) || (3600 * 24 * 7);

// Empty wallet defaults
var wallet = new Wallet();
wallet.datastore.client = 'serverd';
wallet.datastore.client_version = VERSION;
wallet.datastore.network = 'livenet';

var httpsrv = undefined;
var admsrv = undefined;
var db = undefined;
var rpc = undefined;
var network = undefined;

function stop_all()
{
	if (httpsrv)
		httpsrv.close();
	if (admsrv)
		admsrv.close();
}

function dbWriteSync()
{
	var tmpFn = db_fn + ".tmp";
	EncFile.writeJFileSync(ENC_METHOD, process.env.SERVERD, tmpFn, db);
	fs.renameSync(tmpFn, db_fn);

	try {
		wallet.writeSync(walletdb_fn, process.env.SERVERD);
	} catch(e) {
		console.error("Failed to write wallet: " + e);
	}
}

function decodeHexTx(hexStr)
{
	var reHex = /^[0-9a-zA-Z]+$/;
	if (!reHex.test(hexStr))
		return undefined;
	if ((hexStr.length % 2) == 1)
		return undefined;

	var buf = new Buffer(hexStr, 'hex');
	var tx = new Transaction();
	tx.parse(txbuf);

	return tx;
}

function decodePubkey(hexStr)
{
	var buf = new Buffer(hexStr, 'hex');
	if (!buf)
		return undefined;
	var key = new Key();
	key.public = buf;

	return key;
}

function loadChannelKey(channelIdStr)
{
	var channelId = new Buffer(channelIdStr, 'hex');
	var keyObj = wallet.findKeyHash(channelId);
	if (!keyObj)
		return undefined;

	var key = new WalletKey({network: network});
	key.fromObj(keyObj);

	return key;
}

function cmdChannelOpen(req)
{
	// generate a new public key
	var newKey = new WalletKey({network: network});
	newKey.generate();

	// add to wallet
	var obj = newKey.storeObj();
	wallet.addKey(obj);

	var birthday = obj.created;

	// derive channel id (aka bitcoin address) from new key
	var channelId = obj.addr;
	db.channels[channelId] = {
		id: channelId,
		created: birthday,
		state: 'open',
		remotePubkey: '',
		refundTx: '',
	};

	// flush wallet, db updates
	dbWriteSync();

	var result = {
		"pubkey": obj.pub,
		"timelock.min": birthday + timelock_min,
		"timelock.max": birthday + timelock_max,
		"timelock.prefer": birthday + timelock_prefer,
	};
	return jrpcServer.ok(req, result);
}

function validRefundTx(channel, tx)
{
	// must be within permitted time window
	var birthday = channel.created;
	if ((tx.lock_time < (birthday + timelock_min)) ||
	    (tx.lock_time > (birthday + timelock_max)))
		return false;

	// any number of inputs or outputs
	if ((tx.ins.length < 1) || (tx.outs.length < 1))
		return false;

	return true;
}

function cmdChannelSetRefund(req)
{
	// load and validate params
	var params = req.params[0];
	if (!('channel.id' in params) ||
	    !('pubkey' in params) ||
	    !('tx' in params) ||
	    !('txInIdx' in params))
		return jrpcServer.err(req, -10, 'missing params');

	var channelId = params["channel.id"];
	var channel = db.channels[channelId];
	if (!channel)
		return jrpcServer.err(req, -10, 'invalid channel id');
	if (channel.state != 'open')
		return jrpcServer.err(req, -12, 'invalid channel state');
	var channelKey = loadChannelKey(channel.id);
	if (!channelKey)
		return jrpcServer.err(req, -22, 'internal server error');

	var remotePubkey = decodePubkey(params.pubkey);
	if (!remotePubkey)
		return jrpcServer.err(req, -16, 'invalid pubkey');

	var tx = decodeHexTx(params.tx);
	if (!tx)
		return jrpcServer.err(req, -15, 'transaction decode failed');
	if (!validRefundTx(channel, tx))
		return jrpcServer.err(req, -21, 'invalid refund transaction');
	
	var inIdx = parseInt(params.txInIdx);
	if (!inIdx || (inIdx < 0) || (inIdx >= tx.ins.length))
		return jrpcServer.err(req, -21, 'invalid TX input');

	// build scriptPubKey according to standard protocol
	var k1 = remotePubkey.public;
	var k2 = channelKey.public;
	var scriptPubKey = Script.createMultisig(2, [k1, k2]);

	// sign T1, paying to T2, without having ever seen T1
	var txSigHash = tx.hashForSignature(scriptPubKey, inIdx,
					    Transaction.SIGHASH_ALL);
	var sigRaw = channelKey.privKey.signSync(txSigHash);
	var sigType = new Buffer(1);
	sigType[0] = Transaction.SIGHASH_ALL;
	var sig = Buffer.concat([sigRaw, sigType]);

	// update database
	channel.remotePubkey = params.pubkey;
	channel.refundTx = params.tx;
	channel.state = 'signedRefund';
	dbWriteSync();

	var result = {
		"signature": buffertools.toHex(signature),
	};
	return jrpcServer.ok(req, result);
}

function cmdChannelCommit(req)
{
	// load and validate params
	var params = req.params[0];
	if (!('channel.id' in params) ||
	    !('tx' in params))
		return jrpcServer.err(req, -10, 'missing params');

	var channelId = params["channel.id"];
	var channel = db.channels[channelId];
	if (!channel)
		return jrpcServer.err(req, -10, 'invalid channel id');
	if (channel.state != 'signedRefund')
		return jrpcServer.err(req, -12, 'invalid channel state');
	var tx = decodeHexTx(params.tx);
	if (!tx)
		return jrpcServer.err(req, -15, 'transaction decode failed');

	// TODO FIXME

	return jrpcServer.err(req, -99, 'not implemented yet');
}

function cmdChannelSetPayment(req)
{
	// load and validate params
	var params = req.params[0];
	if (!('channel.id' in params) ||
	    !('tx' in params))
		return jrpcServer.err(req, -10, 'missing params');

	var channelId = params["channel.id"];
	var channel = db.channels[channelId];
	if (!channel)
		return jrpcServer.err(req, -10, 'invalid channel id');
	if (channel.state != 'commit')
		return jrpcServer.err(req, -12, 'invalid channel state');
	var tx = decodeHexTx(params.tx);
	if (!tx)
		return jrpcServer.err(req, -15, 'transaction decode failed');

	// TODO FIXME

	return jrpcServer.err(req, -99, 'not implemented yet');
}

function cmdChannelPay(req)
{
	// load and validate params
	var params = req.params[0];
	if (!('channel.id' in params) ||
	    !('signature' in params) ||
	    !('amount' in params))
		return jrpcServer.err(req, -10, 'missing params');

	var channelId = params["channel.id"];
	var channel = db.channels[channelId];
	if (!channel)
		return jrpcServer.err(req, -10, 'invalid channel id');
	if (channel.state != 'active')
		return jrpcServer.err(req, -12, 'invalid channel state');

	// TODO FIXME

	return jrpcServer.err(req, -99, 'not implemented yet');
}

function handle_jsonrpc(req)
{
	if (!Array.isArray(req.params) ||
	    (req.params.length != 1) ||
	    (typeof req.params[0] != 'object'))
		return jrpcServer.err(req, -2, 'invalid params');

	switch (req.method) {
	case "channel.open":
		return cmdChannelOpen(req);
	case "channel.setRefund":
		return cmdChannelSetRefund(req);
	case "channel.commit":
		return cmdChannelCommit(req);
	case "channel.setPayment":
		return cmdChannelSetPayment(req);
	case "channel.pay":
		return cmdChannelPay(req);

	default:
		return jrpcServer.err(req, -1, 'method not found');
	}
}

function handle_jsonrpc_admin(req)
{
	switch (req.method) {
	case "dump":
		return jrpcServer.ok(req, db);

	case "stop":
		stop_all();
		return jrpcServer.ok(req, true);
	
	default:
		return jrpcServer.err(req, -1, 'method not found');
	}
}

function start_http()
{
	var opts = {
		key: fs.readFileSync(sslkey_fn),
		cert: fs.readFileSync(sslcert_fn),
		port: cfg.port || 12882,
	};
	httpsrv = jrpcServer.create(opts, handle_jsonrpc, logger, "http");

	opts = {
		key: fs.readFileSync(sslkey_fn),
		cert: fs.readFileSync(sslcert_fn),
		port: cfg.admin_port || 12883,
	};
	admsrv = jrpcServer.create(opts, handle_jsonrpc_admin, logger, "admin");

	rpc = new RpcClient({
		host: cfg.bitcoind_host || '127.0.0.1',
		port: cfg.bitcoind_port || 18332,
		user: cfg.bitcoind_user || 'user',
		pass: cfg.bitcoind_pass || 'pass',
		protocol: cfg.bitcoind_protocol || 'http',
	});
}

function read_db()
{
	if (program.init) {
		db = {
			created: {
				app:		'serverd',
				version:	VERSION,
				time:		timeUtil.curtime(),
			},

			// member properties:
			// created: creation timestamp (== key generation time)
			// state: open, signedRefund, commit, active
			channels: {},
		};

		dbWriteSync();
	} else {
		db = EncFile.readJFileSync(ENC_METHOD, process.env.SERVERD, db_fn);
		wallet.readSync(walletdb_fn, process.env.SERVERD);
		wallet.setNetwork(wallet.datastore.network);
		network = wallet.network;
	}
}

function main()
{
	if (!process.env.SERVERD) {
		console.error("SERVERD environment variable must be set to DB passphrase");
		return;
	}

	read_db();

	if (!program.init) {
		start_http();
	}
}

main();

